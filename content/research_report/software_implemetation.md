# Software implementation

fMRIprep {cite:p}`fmriprep1` is a popular minimal preprocessing software for functional MRI data.
'Minimal preprocessing' refers to motion correction, field unwarping, normalization, bias field correction, and brain extraction.
Denoising and smoothing are excluded from the workflow.
Instead, fMRIprep provides users with a large set of potential confound regressors that covers many denoising strategies.
The users have to select the confound regressors for denoising in subsequent analyses.
Our aim was to firstly, provide a easy and foolproof API for users to perform subsequent denoising of fMRIprep outputs.
The loaded format is compatible with `nilearn` analysis functions such as `NiftiMasker` and the GLM modules.
Secondly we will show how to generate denoised functional connectivity matrix from fMRIPrep outputs with nilearn. 

## Retrieve fMRIPrep confounds output

To enable easy confound variable loading from fMRIPrep outputs,
confound variables were retrieved using 
(i) a basic API that retrieves different classes of confound regressors,
`nilearn.interfaces.fmriprep.load_confounds` (simplified as `load_confounds`);
and (ii) a higher level wrapper to implement common strategies from the denoising literature,
`nilearn.interfaces.fmriprep.load_confounds_strategy` (simplified as `load_confounds_strategy`).

The following section describes the logic behind the design of the API.
For documentation of the actual function, please see the latest version of [`nilearn` documentation](https://nilearn.github.io/stable/). 

### Basic noise components

`load_confounds` provides an interface that groups subsets of confound variables into noise components and their parameters.
It is possible to fine-tune these subsets through the parameters provided.
The implementation will only support fMRIPrep 1.4.x series or above. <!-- in nilearn we technically only advertise it for LTS versions. -->
User has to keep the outputted functional derivatives directory unchanged.
User gains the maximum amount of freedoms from using this interface, 
and some minimal constraints were implemented based on fMRIPrep documentations. 
Warnings and errors will inform the user if the selected confounds were missing or not suited based on their requests.
The function returns the confound variables and a sample mask per input image.
The sample mask filters out si
The details of each parameter are described in the following section.

Two types of regressors are always loaded with no additional parameters for user customisation:

- `high_pass`: discrete cosine transformation basis regressors to handle low-frequency signal drifts.
- `non_steady_state` denotes volumes collected before the fMRI scanner had reached a stable state.

`motion`, `wm_csf`, and `global_signal` share similar expansion options:

- `motion`: head motion estimates translation/rotation (6 parameters).
- `wm_csf`: average signal extracted from masks of white matter and cerebrospinal fluid (2 parameters).
- `global_signal`: average signal extracted from brain mask (1 parameters).

For the three parameters above, the user can select from the following four options:
- `basic`: original signal only (n parameter)
- `power2`: original signal + quadratic term (2 * n parameters)
- `derivatives`: original signal + temporal derivative (2 * n parameters)
- `full`:  original signal + temporal derivatives + quadratic terms + quadratic terms temporal derivatives (4 * n parameters)

`scrub` generates a mask to exclude volumes with excessive motion {cite:p}`power_scrubbing_2012`.
Three types of parameters can be used to determine volumes to be excluded:
- `fd_threshold`: set the head motion cut-off value determined by framewise displacement approach {cite:p}`power_scrubbing_2012`.
- `std_dvars_threshold`: set the head motion cut-off value determined by the standard deviation of root mean square approach {cite:p}`power_scrubbing_2012,jenkinson_2002`.
- `scrub`: after accounting for time frames with excessive motion, further remove segments shorter than the given number assigned.

The CompCor {cite:p}`behzadi_compcor_2007` approach has two associated parameters:
- `compcor` allows users to select components generated by the temporal approach,
    or the anatomical approach with specific details for the mask used in noise signal extraction.
- `n_compcor` states the number of principal components to retrieve.

For the ICA-based approach, fMRIPrep implemented ICA-AROMA {cite:p}`aroma`.
Users must manually enable ICA-AROMA with flag `--use-aroma` when using fMRIPrep.
The parameter `ica_aroma` allows two approaches:
- `full`: Use fMRIPrep output with suffix `desc-smoothAROMAnonaggr_bold.nii.gz`. This is the standard and recommanded approach.
- `basic`: Use noise independent components only. Must be used with output with suffix `desc-preproc_bold.nii.gz`. 

### Pre-defined strategies

`load_confounds_strategy` provides an interface to select currated confounds based on past literature,
with limited parameters for user customisation.
There are four possible strategies implementable from fMRIPrep confounds:
`simple` {cite:p}`fox_pnas_2005` (motion parameters and tissue signal),
`scrubbing` {cite:p}`power_scrubbing_2012`(volume censoring, motion parameters, and tissue signal),
`compcor` {cite:p}`behzadi_compcor_2007`(anatomical compcor and motion parameters),
and `aroma` {cite:p}`aroma`(ICA-AROMA based denoising and tissue signal).
All strategies, except `compcor`, provide an option to add global signal to the confound regressors.
The predefined strategies with their associated noise component is listed in {numref}`table-predefined_strategies`.
Parameters with `*` denote customisable parameters.

:::{dropdown} Click to see {numref}`table-predefined_strategies`

```{table} Denoising strategies
:name: table-predefined_strategies
| strategy    | image                          | `high_pass` | `motion` | `wm_csf` | `global_signal` | `scrub` | `fd_thresh` | `std_dvars_threshold` | `compcor`        | `n_compcor` | `ica_aroma` | `demean` |
|-------------|--------------------------------|-------------|----------|----------|-----------------|---------|-------------| --------------------- |------------------|-------------|-------------|----------|
| `simple`    | `desc-preproc_bold`            | `True`      | `full`*  | `basic`* | `None`*         | N/A     | N/A         | N/A                   | N/A              | N/A         | N/A         | `True`*  |
| `scrubbing` | `desc-preproc_bold`            | `True`      | `full`*  | `full`   | N/A             | `5`     | `0.5`       | `3`*                  | N/A              | N/A         | N/A         | `True`*  |
| `compcor`   | `desc-preproc_bold`            | `True`      | `full`*  | N/A      | `None`*         | N/A     | N/A         | N/A                   | `anat_combined`* | `all`*      | N/A         | `True`*  |
| `aroma`     | `desc-smoothAROMAnonaggr_bold` | `True`      | N/A      | `basic`* | `None`*         | N/A     | N/A         | N/A                   | N/A              | N/A         | `full`      | `True`*  |
```
:::

## Denoising workflow

The denoising workflow is implemented through `nilearn`. 
{numref}`fig-fmriprep-nilearn-denoise` presents the graphic summary of the workflow.


```{figure} ../images/fig-1-masker.png
---
height: 500px
name: fig-fmriprep-nilearn-denoise
---
Example workflow of extracting denoised timeseries and functional connectomes from fMRIPrep outputs using nilearn.
```